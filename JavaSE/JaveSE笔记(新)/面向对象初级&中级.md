# 面向对象初级&中级

### 面向对象概述

#### 类与对象的区别

```java
1、类是抽象的，概念的，代表一类事物，比如人类，猫类..，即它是数据类型
2、对象是具体的，实际的，代表一个具体事务，即 是实例
3、类是对象的模板，对象是类的一个个体，对应一个实例    
```

#### 属性/成员变量

```java
1、属性是类的一个组成部分，一般是基本数据类型，也可是引用类型(对象，数组)。
2、语法：访问修饰符 属性类型 属性名； private int number;
3、如果属性不赋值，有默认值，规则和数组一致。 
```

#### 内存分配机制

```java
java内存结构：
    1、栈：一般存放基本数据类型(局部变量)
    2、堆：存放对象(Cat car,数组等)
    3、方法区：常量池(常量，比如字符串)，类加载信息
    
对象创建的流程简单分析
    Person p = new Person();
	p.name = "jack";
	p.age = 10;
1、先加载Person类信息(属性和方法信息，只会加载一次)
2、在堆中分配空间，进行默认初始化(看规则)
3、把地址给 p,p就指向对象
4、进行指定初始化，比如p.name = "jack";  p.age = 10;    
```

#### 成员方法

```java
定义：
	public 返回数据类型 方法名(形参列表..){ //方法体
    	语句；
        return 返回值；
	}    
1、形参列表：表示成员输入参数 cal(int n),getSum(int num1,int num2)
2、返回数据类型：表示成员方法输出，void表示没有返回值
3、方法主体：表示为了实现某一功能代码块
4、return 语句不是必须的。    

使用：
//返回数据类型
1、一个方法最多有一个返回值
2、返回类型可以为任意类型
3、如果方法要求有返回数据类型，则方法体重最后的执行语句必须为return值；且返回值类型必须和return的值类型一致或兼容。
4、如果方法时void，则方法体中可以没有return语句
方法名：驼峰式，见名知义，表达出该功能的意思即可。
//形参列表    
一个方法可以0个参数，也可以多个参数，可以是任意类型，调用带参数方法时必须对应着参数列表传入相同类型，顺序、个数必须一致！
```

#### 方法递归调用

```java
//规则：
1.执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2.方法的局部变量是独立的，不会相互影响,比如n变量
3.如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据   
4递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)    
5.当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。     
//使用:   
1、方法名：必须相同
2、形参列表：必须不同(形参类型或个数或顺序，至少有一样无，参数名要求) 3、返回类型：无要求   
```

#### 可变参数

```java
//概念：
java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现
//语法
方法修饰符 返回类型 方法名(数据类型... 形参名){
}
public int sum(int... nums){
}
//使用：
1、可变参数的实参可以为0个或者任意多个
2、可变参数的实参可以为数组。
3、可变参数的本质就是数组
4、可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
5、一个形参列表中只能出现一个可变形参    
```

#### 作用域

```java
1、java作用域分类
    全局变量：也就是属性，作用域为整个类体
    局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中
2、全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。
3、属性和局部变量可以重名，访问时遵循就近原则
4、属性生命周期长，伴随着对象的创建和销毁，局部变量，生命周期短，伴随着它的代码块的执行而创建，代码块结束而销毁，即在一次方法调用过程中
5、作用域范围不同：
    全局变量/属性：可以被本类使用，或其他类使用(通过对象调用)   
    局部变量：只能在本类中对应的方法中使用
6、修饰符不同：
    全局变量/属性可以加修饰符
    局部变量不可以加修饰符  
```

#### 构造方法/构造器

```java
语法：
	[修饰符] 方法名(形参列表){
    	方法体；
	} 
1、构造器的修饰符可以默认，也可以是public protected private
2、构造器没有返回值    
3、方法名和类名字必须一样  
4、参数列表和成员方法一样的规则
5、构造器的调用,由系统完成   
    
构造方法有交构造器(constructor)，是类的一种特殊的方法，主要作用是完成对新对象的初始化，特点：
1、方法名和类名相同
2、没有返回值
3、在创建对象时，系统会自动的调用该类的构造器完成对象的初始化

//使用
1.一个类可以定义多个不同的构造器，即构造器重载    
2.构造器名和类名要相同
3.构造器没有返回值    
4.构造器是完成对象的初始化.并不是创建对象
5.在创建对象时,系统自动的调用该类的构造方法
6.如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造方法(也叫默认构造方法)，比如Person ()0，使用javap指令反编译看看   
7.一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即:Person(){} 
```

#### this关键字

```java
1. this关键字可以用来访问本类的属性、方法、构造器
2. this用于区分当前类的属性和局部变量
3.访问成员方法的语法:this.方法名(参数列表);
4、访问构造器语法:this(参数列表);注意只能在构造器中使用(即只能在构造器中访问另外一个构造器,必须放在第一条语句)
5. this不能在类定义的外部使用，只能在类定义的方法中使用。    
```

#### 包

```java
//作用：
1、区分相同名字的类
2、当类很多时，可以很好的管理类
3、控制访问范围    
//语法 
    package com.Lmj
    1、package 关键字，表示打包
    2、com.Lmj 表示包名
//命名规则
只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字
一般是小写字母+小圆点 
com.公司名.项目名.业务模块名
//常用的包
java.lang.* //lang包是基本包，默认引入,不需要再引入.
java.util.* //util包，系统提供的工具包,工具类，使用 Scanner    
java.net.* //网络包，网络开发
java.awt.* //是做java的界面开发，GUI
```

#### 访问修饰符

```java
java提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围):
1.公开级别:用public修饰.对外公开
2受保护级别:用protected修饰.对子类和同一个包中的类公开
3．默认级别:没有修饰符号.向同一个包的类公开.    
4.私有级别:用private修饰,只有类本身可以访问,不对外公开.    
```

| 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| -------- | -------------- | ---- | ---- | ---- | ------ |
| 公开     | public         | √    | √    | √    | √      |
| 受保护   | protected      | √    | √    | √    | ×      |
| 默认     | 没有修饰符     | √    | √    | ×    | ×      |
| 私有     | private        | √    | ×    | ×    | ×      |

### 面向对象编程三大特征

```java
面向对象编程的三大特征：封装、继承和多态。
```

#### 封装

```java
封装(encapsulate)就是把抽象的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法],才能对数据进行操作。
    
//封装的理解及好处
1）隐藏实现细节：方法（连接数据库）<--调用（传入参数..）
2）可以对数据进行验证，保证安全合理
    Person{name,age}
	Person p = new Person();
	p.name = "jack";
	p.age = 1200;

封装的实现步骤（三步）
1）将属性进行私有化private 【不能直接修改属性】
2）提供一个公共的（public）set方法，用于对属性判断并赋值
    public void setXxx（类型 参数名）{//Xxx 表示某个属性
	//加入数据验证的业务逻辑
    属性 = 参数名;
}
3）提供一个公共的（public）get方法，用于获取属性的值
    public数据类型getXxx(){//权限判断，Xxx某个属性
    	return xx;
	}    
    
```

#### 继承

```java
//继承的基本语法
class 子类 extends 父类{
}
1、子类就会自动拥有父类定义的属性和方法
2、父类又叫 超类，基类。
3、子类又叫派生类    
    
//继承的深入讨论/细节问题
1.子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问
2.子类必须调用父类的构造器，完成父类的初始化
3.当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
4.如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)
5.super在使用时，必须放在构造器第一行（super只能在构造器中使用）
6.super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
7.java所有类都是Object类的子类，Object时所有类的基类。
8.父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）
9.子类最多只能继承一个父类（指直接继承），即Java中时单继承机制
10.不能滥用继承，子类和父类之间必须满足is-a的逻辑关系
```

#### super关键字

```java
基本介绍
super代表父类的引用，用于访问父类的属性、方法、构造器
1.访问父类的属性，但不能访问父类的private属性，super.属性名
2.访问父类的方法，不能访问父类的private方法，super.方法名(参数列表)
3.访问父类的构造器：super(参数列表);只能放在构造器的第一句，只能出现一句！
    
super给编程带来的便利/细节
1.调用父类的构造器的好处(分工明确，父类属性由父类初始化，子类的属性由子类初始化)
2.当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！
3.super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循的就近原则。A->B->C
```

#### super和this的比较

| 区别点     | this                                                   | super                                      |
| ---------- | ------------------------------------------------------ | ------------------------------------------ |
| 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 从父类开始查找属性                         |
| 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类中继续查找 | 从父类开始查找方法                         |
| 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类的构造器，必须放在子类构造器的首行 |
| 特殊       | 表示当前对象                                           | 子类中访问父类对象                         |

#### 方法重写/覆盖(override)

```java
介绍：方法重写就是子类有一个方法，和父类的某个方法的名字、返回类型、参数一样，那么我们就会说子类的这个方法覆盖了父类的方法

//使用条件
1、子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样。
2、子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如 父类 返回类型是 Object，子类方法返回类型是String
3、子类方法不能缩小父类方法的访问权限    
```

#### 方法重载和方法重写对比

| 名称           | 发生范围 | 方法名   | 形参列表                         | 返回类型                                                     | 修饰符                             |
| -------------- | -------- | -------- | -------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| 重载(overload) | 本类     | 必须一样 | 类型，个数或者顺序至少有一个不同 | 无要求                                                       | 无要求                             |
| 重写(override) | 父子类   | 必须一样 | 相同                             | 子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围 |

#### 多态

```java
多态的具体体现
对象的多态（核心、重难点）
1.一个对象的编译类型和运行类型可以不一致
2.编译类型在定义对象时，就确定了，不能改变
3.运行类型时可以变化的
4.编译类型看定义时=号的左边，运行类型看=号的 右边
```

```java
多态的向上转型
前提：两个对象(类)存在继承关系
1.本质：父类的引用指向了子类的对象
2.语法：父类类型 引用名 = new 子类类型();
3.特点：编译类型看左边，运行类型看右边。
  可以调用父类中的所有成员（遵守访问权限），
  不能调用子类中的特有成员；
  最终运行效果看子类的具体实现！
   
多态的向下转型
1.语法： 子类类型 引用名 = (子类类型) 父类引用;
2.只能强转父类的引用，不能强转父类的对象
3.要求父类的引用必须指向的是当前目标类型的对象
4.可以调用子类类型中所有的成员
    
***
属性没有重写之说！属性的值看编译类型
instanceOf比较操作符，用于判断对象的类型是否为XX类型或XX类型的子类型
例：
class AA{}
class BB{}

class test{
	main（main方法下）{
        BB bb = new BB();
        Object obj1 = null;
        System.out.println(bb instanceof AA);
        System.out.println(bb instanceof obj1);
    }
} 
```

```java
Java的动态绑定机制****
1.当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用
例
class AA{
    public void run(){ System.out.println("AA run"); }
    public void eat(){ System.out.println("AA eat"); }
}
class BB extends AA{
    public void run(){ System.out.println("BB run"); }
    public void study(){ System.out.println("BB study"); }
}
main方法{
    	//父类的引用指向子类对象
        AA aa = new BB();//向上转型
        aa.eat(); //AA eat
        aa.run(); //BB run
		//把指向子类对象的父类引用，转成指向子类对象的子类引用
        BB bb = (BB)aa;//向下转型
        bb.run();//BB run
        bb.eat();//AA eat
        bb.study();//BB study
}
```

#### finalize方法

```java
1．当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作
2．什么时候被回收:当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。 3．垃圾回收机制的调用，是由系统来决定(即有自己的GC算法),也可以通过System.gc()主动触发垃圾回收机制。
//在实际开发中，几乎不会运用到finalize.    
```
