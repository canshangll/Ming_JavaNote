# Java基本程序设计结构

### Java开发细节

```java
1. 区分大小写
2. 类名命名驼峰式
3. Java应用程序的执行入口是main()方法
4. 一个源文件中最多只能有一个public类
5. 源文件使用utf-8编码
6. Java源文件.Java为扩展名。源文件的基本组成部分是类（class）
7. 一个源文件中最多只能有一个public类，其他不限，可以将main方法写在非public类中，然后运行非public类，这样入口方法就是非public的main方法    
```

### Java转义字符

```java
Java常用转义字符：
    1） \t：一个制表位，实现对齐的功能
    2） \n：换行符
    3） \\：一个\
    4） \":一个"
    5) \':一个'
    6） \r:一个回车
```

### 数据类型

Java共有8种基本数据类型，其中有4种整型、2种浮点类型、1种字符类型char和表示真值的boolean类型。

#### 整型

整型用于表示没有小数部分的数值，允许是负数。

| 类型  | 存储需求 | 取值范围                                             |
| ----- | -------- | ---------------------------------------------------- |
| int   | 4字节    | -2 147 483 648~2 147 483 647(刚刚超过20亿)           |
| short | 2字节    | -32 768~32 767                                       |
| long  | 8字节    | -9 223 372 036 854 775 808~9 223 372 036 854 775 807 |
| byte  | 1字节    | -128~127                                             |

通常情况下，int类型最常用 。如果想要表示整个地球的人口，就需要使用 long类型。byte和short类型主要用于特定的应用场合，比如：底层的文件处理或者存储空间很宝贵时的大数组。

#### 浮点类型

浮点类型用于表示有小数部分的数值。

| 类型   | 存储需求 | 取值范围                                            |
| ------ | -------- | --------------------------------------------------- |
| float  | 4字节    | 大约 ±3.402 823 47E+38F(有效位数为6~7位)            |
| double | 8字节    | 大约 ±1.797 693 134 862 315 70E+308(有效位数为15位) |

double表示这种类型的数值精度是float类型的两倍(有人称为 双精度数值)。在很多情况下，float类型的精度(6~7位有效数字)并不能满足需求。实际上，只有很少的情况适用float类型。比如：需要单精度数的库，或者需要存储大量数据时。

float类型的数值有一个后缀 F 或 f (例如，3.14F)。没有后缀 F 的浮点数值(如 3.14) 总是默认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如,3.14D) 。

#### boolean类型

boolean(布尔)类型有两个值：false 和 true，用来判定逻辑条件。整型值和布尔值直接不能进行互相转换。

#### char类型

char类型原本用于表示单个字符，但现在情况有所变化，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。

char类型的字面量值要用单引号括起来。例如：'A'是编码值为65的字符常量。它与 "A"不同，"A" 是包含一个字符A的字符串。char类型的值可以表示为十六进制。

### 运算符★

#### 算术运算符：(只列出难点)

| 运算符     | 运算                                               | 范例                     | 结果                 |
| ---------- | -------------------------------------------------- | ------------------------ | -------------------- |
| ++<br />++ | 自增(前)：先运算后取值<br />自增(后)：先取值后运算 | a=2;b=++a<br />a=2;b=a++ | a=3;b=3<br />a=3;b=2 |
| --<br />-- | 自减(前)：先运算后取值<br />自减(后)：先取值后运算 | a=2;b=--a<br />a=2;b=a-- | a=1;b=1<br />a=1;b=2 |
| +          | 字符串相加                                         | "hello"+"world"          | "helloworld"         |

#### 关系运算符：(只列出部分)

| 运算符     | 运算               | 范例                        | 结果  |
| ---------- | ------------------ | --------------------------- | ----- |
| ==         | 相等于             | 8==7                        | false |
| instanceof | 检查是否是类的对象 | "hello" instanceceof String | true  |

#### 逻辑运算符：

```java
逻辑运算符规则：
1、a&b:&叫逻辑与：规则：当a和b同时为true，则结果为true，否则为false
2、a&&b:&&叫短路与：规则：当a和b同时为true，则结果为true，否则为false
3、a|b:|叫逻辑或，规则：当a和b，有一个为true，则结果为true，否则为false
4、a||b:||叫短路或，规则：当a和b，有一个true，则结果为true，否则为false
5、!a:叫取反，或者非运算。当a为true，则结果为false，当a为false时，结果为true
6、a^b：叫逻辑异或，当a和b不同时，则结果为true，否则为false
```

```java
&&和&的区别
1、&&短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false
2、&逻辑与：不管第一个条件是否为false，第二个条件都要判断，效率低
3、开发中，基本是短路与&&，效率高
    
||和|的区别
1、||短路或：如果第一个条件为true，第二个条件不会判断，最终结果为true，效率高
2、|逻辑或：不管第一个条件是否为true，第二个条件都要判断，效率低
3、开发中，基本是逻辑与||，效率高    
```

#### 三元运算符：

```java
基本语法：
    条件表达式？表达式1：表达式2；
1、如果条件表达式为true，运算后的结果时表达式1；
2、如果条件表达式为false，运算后的结果是表达式2；
```

#### 位运算符

```java
1、算术右移 >>：低位溢出，符号位不变，并用符号位补溢出的高位
2、算术左移 <<：符号位不变，低位补0
3、>>>逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补0
4、特殊说明：没有 <<< 符号
例子：
int a=1>>2;// 1=>00000001 => 00000000 本质 1/2/2=0
int a=1<<2;// 1=>00000001 => 00000100 本质 1*2*2=0   
```

### 变量和常量

变量

```java
1、变量名必须是一个字母开头并有字母或数字构成的序列
2、不能使用java保留字作为变量名
3、声明一个变量之后，必须用赋值语句对变量进行显示初始化
4、变量的声明尽可能地靠近变量第一次使用得地方，这是一种良好的程序编写风格
```

常量

```java
1、java中，利用关键字final指示常量 final double CM_PER_INCE = 2.54;
2、关键字final表示这个变量只能被赋值一次。一旦赋值就不能再更改，习惯上，常量名使用全大写
3、希望某个常量可以在一个类的多个方法中使用，可以使用关键字 static final设置一个类常量
```

### 数学函数及常量

```java
Math类提供了一些常用三角函数：
    Math.sin		
    Math.cos
    Math.tan
    Math.atan
    Math.atan2
指数函数以及它的反函数——自然对数以及对10为底的对数：
    Math.exp
    Math.log
    Math.log10
Java还提供了两个用于表示 π和e常量的最接近的近似值
    Math.PI
    Math.E
//可以不必再数学方法名和常量名前添加前缀“Math”，只要在源文件的顶部加上下面代码就可以了：
    import static java.lang.Math.*;
```

### 类型转换

自动类型转换

```java
1、有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算
2、（byte,short）和char之间不会相互转换。
3、byte,short,char 三者可以计算
4、boolean不参与转换
5、自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型
```

强制类型转换

```java
1、将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符()，但可能造成精度降低或溢出，格外要注意。
2、强制符号只针对于最近的操作数有效，往往会使用小括号提升优先级
3、char类型可以保存int的常量值，但不能保存int的变量值，需要强转
4、byte和short类型在进行运算时，当做int类型处理
```

基本数据类型和String类型的转换

```java
基本类型转String类型语法:将基本类型的值+""
String通过基本类型的包装类调用parseXX方法
==========注意事项===========    
在将String类型转换成基本数据类型时，要确保String类型能够转成有效的数据。如果格式不正确，会抛出异常。
```

### 字符串

java字符串就是Unicode字符序列，Java没有内置的字符串类型，而是在标准java类库中提供了一个预定义类，叫做String。每个用双引号括起来的字符串都是String类的一个实例：

String greeting = "Hello";

#### 判断字符串大小

```java
//可以使用equals方法检查两个字符串是否相等：s.equals(t)
如果 字符串s与字符串t相等，则返回true，否则返回false，需要注意的是，s与t可以是字符串的变量，也可以是字符串字面量    
//要检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。
    
***注意***    
一定不要使用 == 运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否存放在同一个位置上。
    String str = "Hello"
    if(str == "Hello")...
        //true
    if(str.substring(0,3)=="Hel")...
        //false
如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上只有字符串字面量是共享的，而 + 或 substring 等操作得到的字符串并不共享，因此不要使用 == 运算符测试字符串的相等性。
```

#### 空串和Null串

```java
空串 ""是长度为0的字符串。可以调用一下代码检测一个字符串是否为空
    if(str.length()==0) 或 if(str.equals(""))
空串是一个java对象，有自己的长度(0)和内存(空)。
在String变量还可以存放一个特殊的值，名为null，表示目前没有任何对象与该变量关联。
检测一个字符串是否为null:
	if(str == null)
如果要检查一个字符串既不是null也不是空串：
	if(str !=null && str.length() !=0)    
```

#### StringAPI(常用)

java.lang.String

```java
equals //区分大小写，判断内容是否相等
equalslgnoreCase //忽略大小写的判断内容是否相等
length //获取字符的个数，字符串的长度    
indexOf //获取字符在字符串中第1次出现的索引,索引从0开始,如果找不到,返回-1. 
lastIndexOf //获取字符在字符串中最后1次出现的索引,索引从0开始,如找不到,返回-1
substring //截取指定范围的子串    
trim//去前后空格
charAt //获取某索引处的字符,注意不能使用Str[index]这种方式.    
toUpperCase //返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字符改成大写字符。
toLower
Caseconcat    
replace //替换字符串中的字符    
split //分割字符串,对于某些分割字符，我们需要转义比如|I1等    
compareTo //比较两个字符串的大小
toCharArray //转换成字符数组    
format //格式字符串,%s字符串%c字符%d整型%.2f 浮点型    
```

#### 构建字符串StringBuild

有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。如果采用字符串拼接的方式来达到这个目的，效率会比较低。每次拼接字符串时，都会构建一个新的String对象，既耗时，又浪费空间。使用StringBuild类就可以避免这个问题的发生

```java
如果需要用许多小段的字符串来构建一个字符串：
	StringBuild builder = new StringBuild();
当每次需要添加一部分内容时，就调用append方法
    builder.append(ch);
	builder.append(str);
在字符串构建完成时就调用toString方法，就可以得到一个String对象，其中包含了构建器的字符序列。
    String completedString = builder.toString();
```

### 输入与输出

输出：System.out.println。

读取 标准输入流：

```java
import java.util.*;//引入

Scanner in = new Scanner(System.in);
System.out.println("你的名字是：");
String name = in.nextLine();//读取 输入的值
//读取 整数： in.nextInt(); 读取 浮点数 nextDouble
```

### 控制流程

#### 条件语句

```java
if(条件表达式1){
    执行代码块1
}eles if(条件表达式2){
    执行代码块2
}
.....
else{
    执行代码块n;
}
```

#### While循环

```java
while(循环条件){
    循环体(语句);
    循环变量迭代;
}

do{
    循环体(语句);
    循环变量迭代;
}while(循环条件)
```

#### for循环

```java
for(循环变量初始化;循环条件;循环变量迭代){
    循环操作(可以多条语句);
}
for(;;){
    //表示无限循环
}
```

#### Switch语句

```java
switch(表达式){
    case 常量1://当...
        语句块1;
        breack;
    case 常量2:
        语句块2;
        breack;   
    .........
    case 常量n:
        语句块n;
        breack;    
	default:语句块;
        break;
}
```

#### breack,continue,return

```java
break语句出现在多层嵌套的语句块时，可以通过标签指明要终止的是哪一层语句块。
1、如果没有指定break,默认退出最近的循环体。
2、实际开发中，尽量不使用标签

continue语句用于结束本次循环，继续执行下一次循环
可以是通过标签指明要跳过的哪一层循环，和break语句一样，不建议使用
int i = 1;
while(i<=4){
    i++;
    if(i==2){
        continue;
    }
    System.out.println("i="+i);//3 4 5
}
    
return:表示跳出所在方法。
```

### 数组

```java
创建数组：
    int[] a = new int[5];或
	int a[] = {2,3,4,5,6};
使用：
    1、数组是多个相同数据类型的组合。
    2、数组中的元素可以是任何数据类型，包括基本类型和引用类型，但不能混用
    3、数组创建后，如果没有赋值，有默认值：int-0,short-0,byte-0,long-0,float-0.0,double-0.0,char-\u0000,boolean-false,String-null。
    4、数组的下标从0开始。
    5、数组下标必须在指定范围内使用，否则：下标越界异常
    6、数组属于引用类型，数组型数据时对象(Object)
```

#### 数组赋值机制

```java
1、基本数据类型赋值，这个值就是具体的数据，而且相互不影响、
2、数组在默认情况下是引用传递，赋的值是地址。
        int[] arr1 = {1,2,3};
        int[] arr2 = arr1;
        arr2[0] = 10;
        System.out.println("arr1="+arr1 + "\n"+"arr2="+arr2);
		//arr1=[I@75b84c92  arr2=[I@75b84c92
        System.out.println("arr1[0]="+arr1[0] + "\n"+"arr2[0]="+arr2[0]);
		//arr1[0]=10  arr2[0]=10
```

#### 数组排序

```java
读数组型数组进行排序，可以使用Arrays类中sort方法，这个方法使用了快速排序(QuickSort)算法。快速排序算法对于大多数数据集合来说都是效率比较高的。
        int[] arr1 = {9,8,6,7,10,56,48,2};
        for (int i : arr1) {
            System.out.print(i+"\t");//9	8	6	7	10	56	48	2
        }
        Arrays.sort(arr1);
        for (int i : arr1) {
            System.out.print(i+"\t");//2	6	7	8	9	10	48	56
        }
```

#### 二维数组

```java
语法：int a[][] = new int[2][3];      
```

